#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;
use Getopt::Long;
use File::Slurp ();
use PPI;

my $LIB;
BEGIN {
    use FindBin;
    $LIB = "$FindBin::Bin/lib/";   
}

use Test::More;
use FindBin;
use lib $LIB;

use constant DEPS => $FindBin::Bin . q{/perl-dependencies};

my ( $verbose, $help, $debug );

# convenient feature for the purpose of this talk
$ENV{PERL5LIB} .= qq{:$LIB} if -d $LIB;

GetOptions(
    "verbose!" => \$verbose,
    "debug!"   => \$debug,
    "help!"    => \$help,
) or do { usage(); exit 1; };

do { usage(); exit } if $help;

unless (@ARGV) {
    die "Missing argument: did your forget to specify the script or package path ?\n";
}

$verbose = 1 if $debug;

sub verbose {
    my (@msg) = @_;
    return unless $verbose;
    return say @msg;
}

exit run(@ARGV);

sub run {
    my ($script) = @_;

    -f $script or do { say "Usage: $0 script.pl"; return 1 };
    -x DEPS or return 1;

    my @cmd = ( DEPS, '--files', $script );
    verbose( "# ", join ' ', @cmd );
    my @deps = qx{@cmd};
    chomp @deps;

    my $fat = $script . q{.fat};

    my @lsfiles = qx{git ls-files};    # could also use the Git object there...
    chomp @lsfiles;
    my %in_repo = map { $_ => 1 } @lsfiles;

    File::Slurp::write_file( $fat, qq{#!$^X\n\n# generated by $0\n} );

    my %to_pack;
    foreach my $d (@deps) {
        my $module = _to_module($d);
        if ( $in_repo{$d} ) {
            $to_pack{$module} = $d;            
        } else {
            if ( $in_repo{"lib/$d"} ) {
                $to_pack{$module} = "lib/$d";
            }
        }
    }

    my @inc;
    push @inc, qq[BEGIN {\n];
    foreach my $k ( sort values %to_pack ) {
        my $path = $k;
        $path =~ s{^lib/}{};
        push @inc, "\t\$INC{'$path'} = '__YAPACK__';\n";
    }
    push @inc, "}\n\n";

    File::Slurp::write_file( $fat, { append => 1 }, @inc );

    my %data;
    my %content;

    foreach my $module ( sort keys %to_pack ) {
        my $p = $to_pack{$module};

        verbose("- packing $p");

        my @read = File::Slurp::read_file($p);

        # this is adding some extra slowness to the script
        #   but this avoid us to parse the file to detect dependencies
        my @cmd = ( DEPS, $p );
        my @deps_for_module = qx{@cmd};
        @deps_for_module = () if $? != 0;
        chomp @deps_for_module;

        $data{$module} //= {};
        $data{$module}->{deps} //= \@deps_for_module;

        my @cut;
        foreach my $line (@read) {
            last if $line =~ m/^__END__/;
            if ( $line =~ qr{^\s*(?:use|require)\s+([^\s]+)\b} ) {
                my $mod = $1;
                if ( $to_pack{$mod} ) {
                    $line = "#$line # -- packed";    # comment the line
                                          #push @{$data{$module}->{deps}}, $mod;
                }
            }

            if ( $line =~ qr{^\s*use\s+(?:base|parent)\s+q?w?['"\{]([^\s'"\}]+)} ) {
                my $base = $1;
                if ( $to_pack{$base} ) {
                    $data{$base} //= {};
                    $data{$base}->{is_base} = 1;
                }
            }

            push @cut, $line;
        }
        @read = @cut;

        $content{$module} = \@read;
    }

    my $module_sorted = _sort_deps( \%data );

    my $c = 0;
    verbose("\nWriting modules to fatpacked in dependencies order");
    foreach my $module (@$module_sorted) {
        verbose( ++$c, " - ", $module );
        my $read = $content{$module};
        next unless ref $read;
        my $content = join '', @$read;

        # remove pod from file: also avoid issues when packing a module with POD at the end incorrectly finished
        my $Document = PPI::Document->new( \$content );
        $Document->prune('PPI::Token::Pod');

        # only wrap it after removing pods
        my $str = qq[{ # ---- START $module\n] . $Document->serialize . qq[\n} # ---- END $module\n\n];

        File::Slurp::write_file( $fat, { append => 1 }, $str );

        if ($debug) {    # allow us to detect from which package a packing issue comes from
            qx{$^X -c $fat};
            die if $? != 0;
        }

    }

    my $main = PPI::Document->new($script);
    $main->prune('PPI::Token::Pod');

    # could also remove use / require using  PPI::Statement::Include
    my $txt = $main->serialize;
    my @lines = split(/\n/, $txt);
    foreach my $line ( @lines ) {
        if ( $line =~ qr{^\s*(?:use|require)\s+([^\s]+)\b} ) {
            my $mod = $1;
            if ( $to_pack{$mod} ) { # FIXME
                $line = "#$line # -- packed";    # comment the line
            }
        }
    }

    # now append the main script...
    my @read = (
        "\n\n# ---- $script fatpacked by $0\n\n",
        qq{package main;\n\n}    # avoid to use previous package name
        #, $main->serialize,
        , join( "\n", @lines),
        "\n"
    );
    File::Slurp::write_file( $fat, { append => 1 }, @read );
    qx{chmod +x $fat} if $fat =~ m{\.pl\.fat$};
    qx{$^X -c $fat};
    return $?;
}

sub _sort_deps {
    my $data = shift;

    my @sorted = sort {

        my $a_needs_b = grep { $b eq $_ } @{ $data->{$a}->{deps} };
        return 1 if $a_needs_b;

        my $b_needs_a = grep { $a eq $_ } @{ $data->{$b}->{deps} };
        return -1 if $b_needs_a;


        # need to sort them in a consistent order, do our best
        return ( $data->{$b}->{is_base} || 0 ) <=> ( $data->{$a}->{is_base} || 0 )
          || scalar @{ $data->{$a}->{deps} } <=> scalar @{ $data->{$b}->{deps} }    # proof of weakness
          || length $a <=> length $b
          || $a cmp $b;

    } sort keys %$data;    # second proof of weakness here...

    return \@sorted;
}

sub _to_path {
    my $s = shift;
    $s =~ s{::}{/}g;
    $s .= '.pm';

    return $s;
}

sub _to_module {
    my $s = shift;
    
    $s =~ s{\.pm$}{};
    $s =~ s{/+}{::}g;

    return $s;
}


sub usage {
    print <<EOU;
 $0 Yet Another Packing system

 Pack a perl script in a single '.fat' file.
 Only modules in WHM git repository are packed to the script.

options:
    --help          this help (amazing)
    --verbose       add some extra informations while packing (disabled by default)
    --debug         enable verbose and perform some extra checks for debugging (slower)

The argument can be a module, a package or a script.

Sample usages:
> $0 lib/My/Module.pm
> $0 --verbose my-script.pl

EOU

    return;
}
